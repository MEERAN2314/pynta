# Unifyt v0.3.0 - New Features Guide

Welcome to Unifyt v0.3.0! This release brings powerful new features for scientific computing, measurement analysis, and enhanced developer experience.

## Table of Contents

1. [Uncertain Quantities](#uncertain-quantities)
2. [Advanced Formatting](#advanced-formatting)
3. [Unit Validation](#unit-validation)
4. [Batch Operations](#batch-operations)
5. [Performance Profiling](#performance-profiling)
6. [Metric Prefixes](#metric-prefixes)
7. [Migration from v0.2.0](#migration-from-v020)

---

## Uncertain Quantities

### Overview

`UncertainQuantity` extends `Quantity` to support measurements with error margins. Perfect for experimental physics, chemistry, and any field dealing with measurement uncertainty.

### Basic Usage

```python
from unifyt import UncertainQuantity

# Create measurement with absolute uncertainty
length = UncertainQuantity(100.0, 'meter', uncertainty=0.5)
print(length)  # 100.0 ± 0.5 meter

# Create with relative uncertainty (5%)
mass = UncertainQuantity(50.0, 'kilogram', relative_uncertainty=0.05)
print(mass)  # 50.0 ± 2.5 kilogram
```

### Automatic Error Propagation

Uncertainties propagate automatically through all operations:

```python
# Addition/Subtraction: σ = √(σ₁² + σ₂²)
a = UncertainQuantity(100, 'meter', uncertainty=1)
b = UncertainQuantity(50, 'meter', uncertainty=0.5)
total = a + b
print(total)  # 150.0 ± 1.118 meter

# Multiplication/Division: relative uncertainties combine
length = UncertainQuantity(10.0, 'meter', uncertainty=0.1)
width = UncertainQuantity(5.0, 'meter', uncertainty=0.05)
area = length * width
print(area)  # 50.0 ± 0.559 meter^2

# Power: σᵣₑₗ = |n| × σᵣₑₗ,ₓ
side = UncertainQuantity(10.0, 'meter', uncertainty=0.1)
volume = side ** 3
print(volume)  # 1000.0 ± 30.0 meter^3
```

### Unit Conversions

Uncertainties are preserved during unit conversions:

```python
distance = UncertainQuantity(100, 'meter', uncertainty=0.5)
distance_km = distance.to('kilometer')
print(distance_km)  # 0.1 ± 0.0005 kilometer
```

### Real-World Example: Pendulum Experiment

```python
import math
from unifyt import UncertainQuantity

# Measurements
period = UncertainQuantity(2.01, 'second', uncertainty=0.02)
length = UncertainQuantity(1.00, 'meter', uncertainty=0.01)

# Calculate g = 4π²L/T²
g = (4 * math.pi**2 * length) / (period ** 2)
print(f"g = {g}")
print(f"Relative uncertainty: {g.relative_uncertainty.item():.2%}")
```

---

## Advanced Formatting

### Overview

Format quantities in multiple styles for different output needs: LaTeX documents, Unicode terminals, HTML pages, or scientific notation.

### Quick Formatting

```python
from unifyt import Quantity, format_quantity

speed = Quantity(100, 'meter/second')

# Different styles
print(format_quantity(speed, style='default'))     # 100 meter/second
print(format_quantity(speed, style='latex'))       # LaTeX format
print(format_quantity(speed, style='unicode'))     # Unicode superscripts
print(format_quantity(speed, style='html'))        # HTML markup
print(format_quantity(speed, style='compact'))     # 100meter/second
print(format_quantity(speed, style='scientific'))  # 1.000000e+02 meter/second
```

### Custom Formatter

```python
from unifyt import QuantityFormatter

# Create formatter with custom settings
formatter = QuantityFormatter(
    style='latex',
    precision=3,
    compact=False
)

energy = Quantity(1.602e-19, 'joule')
print(formatter.format(energy))
```

### Style Examples

**LaTeX** - Perfect for scientific papers:
```python
q = Quantity(9.81, 'meter/second^2')
print(format_quantity(q, style='latex'))
# Output: \frac{meter}{second^{2}}
```

**Unicode** - Beautiful terminal output:
```python
q = Quantity(100, 'meter^2')
print(format_quantity(q, style='unicode'))
# Output: 100 meter²
```

**HTML** - Web applications:
```python
q = Quantity(100, 'meter^2')
print(format_quantity(q, style='html'))
# Output: 100 meter<sup>2</sup>
```

---

## Unit Validation

### Overview

Validate units before use, get suggestions for typos, and check dimensionality compatibility.

### Basic Validation

```python
from unifyt import validate_unit, suggest_unit

# Check if unit is valid
print(validate_unit('meter'))  # True
print(validate_unit('invalid_unit'))  # False

# Get suggestions for typos
print(suggest_unit('metr'))  # ['meter', 'meters']
print(suggest_unit('secnd'))  # ['second', 'seconds']
```

### Advanced Validation

```python
from unifyt import UnitValidator

validator = UnitValidator()

# Validate with error message
is_valid, error = validator.validate('meter')
print(f"Valid: {is_valid}, Error: {error}")

# Check dimensionality compatibility
is_compat, msg = validator.check_dimensionality('meter', 'foot')
print(f"Compatible: {is_compat}")  # True

is_compat, msg = validator.check_dimensionality('meter', 'second')
print(f"Compatible: {is_compat}")  # False
print(f"Reason: {msg}")
```

### Unit Simplification

```python
validator = UnitValidator()

# Simplify complex units
complex_unit = 'meter * second / second'
simplified = validator.simplify_unit(complex_unit)
print(simplified)  # 'meter'

# Parse compound units
components = validator.parse_compound_unit('meter/second^2')
print(components)  # {'meter': 1.0, 'second': -2.0}
```

---

## Batch Operations

### Overview

Process multiple quantities efficiently with batch converters and statistical operations.

### Basic Batch Conversion

```python
from unifyt import Quantity, convert_batch

distances = [
    Quantity(100, 'meter'),
    Quantity(1, 'kilometer'),
    Quantity(50, 'foot')
]

# Convert all to same unit
distances_km = convert_batch(distances, 'kilometer')
for d in distances_km:
    print(d)
```

### Statistical Operations

```python
from unifyt import BatchConverter

converter = BatchConverter()

measurements = [
    Quantity(100, 'meter'),
    Quantity(150, 'meter'),
    Quantity(200, 'meter')
]

# Calculate statistics
total = converter.sum_quantities(measurements)
mean = converter.mean_quantities(measurements)
min_val = converter.min_quantity(measurements)
max_val = converter.max_quantity(measurements)

print(f"Total: {total}")
print(f"Mean: {mean}")
print(f"Min: {min_val}")
print(f"Max: {max_val}")
```

### Normalize Units

```python
# Mixed units
mixed = [
    Quantity(100, 'meter'),
    Quantity(1, 'kilometer'),
    Quantity(50, 'foot')
]

# Normalize to common unit
normalized = converter.normalize_units(mixed, 'meter')
for q in normalized:
    print(q)
```

### Dictionary Operations

```python
data = {
    'distance_a': Quantity(100, 'meter'),
    'distance_b': Quantity(1, 'kilometer'),
    'distance_c': Quantity(50, 'foot')
}

# Convert all values
converted = converter.convert_dict(data, 'meter')
for name, value in converted.items():
    print(f"{name}: {value}")
```

---

## Performance Profiling

### Overview

Monitor and optimize your code with built-in performance profiling tools.

### Basic Profiling

```python
from unifyt import get_profiler, enable_profiling, print_profiling_stats

enable_profiling()
profiler = get_profiler()

# Profile a code block
with profiler.profile('conversion'):
    for _ in range(1000):
        q = Quantity(100, 'meter').to('kilometer')

# Print statistics
print_profiling_stats()
```

### Function Profiling

```python
from unifyt import profile_function

@profile_function('my_calculation')
def calculate_energy(mass, velocity):
    return 0.5 * mass * velocity ** 2

# Function calls are automatically profiled
energy = calculate_energy(
    Quantity(10, 'kilogram'),
    Quantity(5, 'meter/second')
)
```

### Detailed Statistics

```python
profiler = get_profiler()

# Get statistics for specific operation
stats = profiler.get_stats('conversion')
print(f"Count: {stats['count']}")
print(f"Mean time: {stats['mean']*1000:.3f} ms")
print(f"Std dev: {stats['std']*1000:.3f} ms")
print(f"Min: {stats['min']*1000:.3f} ms")
print(f"Max: {stats['max']*1000:.3f} ms")

# Export all statistics
all_stats = profiler.export_stats()
```

### Control Profiling

```python
from unifyt import enable_profiling, disable_profiling, reset_profiling

# Enable/disable profiling
enable_profiling()
# ... code to profile ...
disable_profiling()

# Reset profiling data
reset_profiling()
```

---

## Metric Prefixes

### Overview

Automatically generate prefixed units (kilo-, mega-, micro-, etc.) for custom units.

### SI Prefixes

```python
from unifyt import UnitRegistry, prefixes

registry = UnitRegistry()

# Add prefixes to a custom unit
registry.define('parsec', '3.086e16 meter')
prefixes.add_prefixes_to_unit(
    registry,
    'parsec',
    '3.086e16 meter',
    prefixes=['kilo', 'mega', 'giga']
)

# Now you can use: kiloparsec, megaparsec, gigaparsec
```

### Generate Common Prefixes

```python
# Generate standard prefixed units
prefixes.generate_common_prefixed_units(registry)

# This creates:
# - kilometer, centimeter, millimeter, etc.
# - kilogram, milligram, microgram, etc.
# - millisecond, microsecond, nanosecond, etc.
```

### Binary Prefixes

```python
# Add binary (IEC) prefixes
prefixes.add_binary_prefixes_to_unit(registry, 'byte', '8 bit')

# Now you can use: kibibyte, mebibyte, gibibyte, etc.
```

### Parse Prefixed Units

```python
# Parse unit string with prefix
base, factor = prefixes.parse_prefixed_unit('kilometer')
print(f"Base: {base}, Factor: {factor}")  # Base: meter, Factor: 1000.0
```

### Available Prefixes

**SI Prefixes:**
- Large: yotta (10²⁴), zetta (10²¹), exa (10¹⁸), peta (10¹⁵), tera (10¹²), giga (10⁹), mega (10⁶), kilo (10³)
- Small: milli (10⁻³), micro (10⁻⁶), nano (10⁻⁹), pico (10⁻¹²), femto (10⁻¹⁵), atto (10⁻¹⁸), zepto (10⁻²¹), yocto (10⁻²⁴)

**Binary Prefixes:**
- kibi (2¹⁰), mebi (2²⁰), gibi (2³⁰), tebi (2⁴⁰), pebi (2⁵⁰), exbi (2⁶⁰)

---

## Migration from v0.2.0

### Backward Compatibility

All v0.2.0 code works without changes in v0.3.0. New features are additive.

### Adopting New Features

**Before (v0.2.0):**
```python
from unifyt import Quantity

distance = Quantity(100, 'meter')
result = distance.to('kilometer')
```

**After (v0.3.0) - with new features:**
```python
from unifyt import UncertainQuantity, format_quantity, validate_unit

# Validate before use
if validate_unit('meter'):
    # Use uncertain quantities
    distance = UncertainQuantity(100, 'meter', uncertainty=0.5)
    result = distance.to('kilometer')
    
    # Format output
    print(format_quantity(result, style='latex'))
```

### Recommended Upgrades

1. **For experimental data**: Use `UncertainQuantity` instead of `Quantity`
2. **For reports**: Use `format_quantity()` with appropriate style
3. **For validation**: Add `validate_unit()` checks before creating quantities
4. **For batch processing**: Use `BatchConverter` for multiple quantities
5. **For optimization**: Enable profiling to find bottlenecks

---

## Summary

Unifyt v0.3.0 brings professional-grade features for scientific computing:

- ✅ **Uncertain Quantities**: Proper error propagation
- ✅ **Advanced Formatting**: Multiple output styles
- ✅ **Unit Validation**: Catch errors early
- ✅ **Batch Operations**: Efficient processing
- ✅ **Performance Profiling**: Optimize your code
- ✅ **Metric Prefixes**: Auto-generate units
- ✅ **100% Backward Compatible**: No breaking changes

See `examples/v0.3.0_features.py` for complete working examples!
