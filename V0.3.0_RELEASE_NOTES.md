# Unifyt v0.3.0 Release Notes

**Release Date:** December 29, 2024

## üéâ Major Release - Professional Scientific Computing Features

Unifyt v0.3.0 is a major feature release that transforms Unifyt into a professional-grade scientific computing library with advanced measurement analysis, validation, and performance tools.

---

## üöÄ What's New

### 1. **Uncertain Quantities** - Measurement Error Propagation

The new `UncertainQuantity` class brings professional error analysis to Unifyt:

```python
from unifyt import UncertainQuantity

# Create measurements with uncertainties
length = UncertainQuantity(100.0, 'meter', uncertainty=0.5)
width = UncertainQuantity(50.0, 'meter', uncertainty=0.3)

# Automatic error propagation
area = length * width
print(area)  # 50.0 ¬± 0.559 meter^2
```

**Features:**
- Automatic uncertainty propagation through all operations
- Support for absolute and relative uncertainties
- Follows standard error propagation formulas
- Unit conversions preserve uncertainties
- Perfect for experimental physics, chemistry, and engineering

**Use Cases:**
- Laboratory measurements
- Experimental data analysis
- Quality control
- Scientific research
- Engineering calculations

---

### 2. **Advanced Formatting** - Multiple Output Styles

Format quantities for any output medium:

```python
from unifyt import Quantity, format_quantity

speed = Quantity(100, 'meter/second')

print(format_quantity(speed, style='latex'))      # For papers
print(format_quantity(speed, style='unicode'))    # For terminals
print(format_quantity(speed, style='html'))       # For web
print(format_quantity(speed, style='scientific')) # For data
```

**Supported Formats:**
- `default`: Standard text output
- `latex`: LaTeX mathematical notation
- `unicode`: Unicode with superscripts/subscripts
- `html`: HTML with proper markup
- `compact`: Space-efficient notation
- `scientific`: Scientific notation

**Use Cases:**
- Scientific papers (LaTeX)
- Web applications (HTML)
- Terminal output (Unicode)
- Data export (Scientific)
- Reports and presentations

---

### 3. **Unit Validation** - Catch Errors Early

Validate units before use and get helpful suggestions:

```python
from unifyt import validate_unit, suggest_unit, UnitValidator

# Quick validation
print(validate_unit('meter'))  # True
print(validate_unit('metr'))   # False

# Get suggestions for typos
print(suggest_unit('metr'))  # ['meter', 'meters']

# Advanced validation
validator = UnitValidator()
is_compat, msg = validator.check_dimensionality('meter', 'second')
print(is_compat)  # False - incompatible dimensions
```

**Features:**
- Validate unit strings before creating quantities
- Typo detection with Levenshtein distance
- Dimensionality compatibility checking
- Unit simplification
- Compound unit parsing

**Use Cases:**
- User input validation
- API parameter checking
- Configuration file validation
- Interactive applications
- Error prevention

---

### 4. **Batch Operations** - Efficient Processing

Process multiple quantities efficiently:

```python
from unifyt import Quantity, BatchConverter, convert_batch, sum_batch

distances = [
    Quantity(100, 'meter'),
    Quantity(1, 'kilometer'),
    Quantity(50, 'foot')
]

# Convert all to same unit
results = convert_batch(distances, 'meter')

# Calculate statistics
converter = BatchConverter()
total = converter.sum_quantities(distances)
mean = converter.mean_quantities(distances)
min_val = converter.min_quantity(distances)
max_val = converter.max_quantity(distances)
```

**Features:**
- Batch unit conversions
- Statistical operations (sum, mean, min, max)
- Dictionary operations
- Unit normalization
- Efficient processing

**Use Cases:**
- Data analysis
- Sensor data processing
- Batch conversions
- Statistical analysis
- Data pipelines

---

### 5. **Performance Profiling** - Optimize Your Code

Monitor and optimize performance:

```python
from unifyt import get_profiler, enable_profiling, print_profiling_stats

enable_profiling()
profiler = get_profiler()

# Profile operations
with profiler.profile('conversion'):
    for _ in range(1000):
        q = Quantity(100, 'meter').to('kilometer')

# View statistics
print_profiling_stats()
```

**Features:**
- Context manager for profiling blocks
- Function decorator for profiling
- Detailed statistics (count, mean, std, min, max, median)
- Global profiler instance
- Export statistics for analysis

**Use Cases:**
- Performance optimization
- Bottleneck identification
- Benchmarking
- Code optimization
- Performance monitoring

---

### 6. **Metric Prefixes** - Auto-Generate Units

Automatically generate prefixed units:

```python
from unifyt import UnitRegistry, prefixes

registry = UnitRegistry()

# Add prefixes to custom unit
registry.define('parsec', '3.086e16 meter')
prefixes.add_prefixes_to_unit(
    registry, 'parsec', '3.086e16 meter',
    prefixes=['kilo', 'mega', 'giga']
)

# Now use: kiloparsec, megaparsec, gigaparsec
```

**Features:**
- SI prefixes (yotta to yocto)
- Binary prefixes (kibi, mebi, gibi, etc.)
- Custom unit prefix generation
- Prefix parsing
- Symbol support

**Use Cases:**
- Custom unit systems
- Domain-specific units
- Astronomical units
- Data storage units
- Scientific notation

---

## üìä Feature Comparison

| Feature | v0.1.0 | v0.2.0 | v0.3.0 |
|---------|--------|--------|--------|
| Units | 100+ | 300+ | 300+ |
| Constants | 30+ | 80+ | 80+ |
| Uncertain Quantities | ‚ùå | ‚ùå | ‚úÖ |
| Advanced Formatting | ‚ùå | ‚ùå | ‚úÖ |
| Unit Validation | ‚ùå | ‚ùå | ‚úÖ |
| Batch Operations | ‚ùå | ‚ùå | ‚úÖ |
| Performance Profiling | ‚ùå | ‚ùå | ‚úÖ |
| Metric Prefixes | ‚ùå | ‚ùå | ‚úÖ |
| Exception Types | 5 | 25+ | 25+ |

---

## üîÑ Migration Guide

### From v0.2.0 to v0.3.0

**Good News:** 100% backward compatible! All v0.2.0 code works without changes.

**Recommended Upgrades:**

1. **For experimental data:**
   ```python
   # Before
   measurement = Quantity(100, 'meter')
   
   # After
   measurement = UncertainQuantity(100, 'meter', uncertainty=0.5)
   ```

2. **For output formatting:**
   ```python
   # Before
   print(quantity)
   
   # After
   print(format_quantity(quantity, style='latex'))
   ```

3. **For validation:**
   ```python
   # Before
   try:
       q = Quantity(value, unit_string)
   except:
       pass
   
   # After
   if validate_unit(unit_string):
       q = Quantity(value, unit_string)
   else:
       suggestions = suggest_unit(unit_string)
   ```

4. **For batch processing:**
   ```python
   # Before
   results = [q.to('meter') for q in quantities]
   
   # After
   results = convert_batch(quantities, 'meter')
   ```

---

## üìö Documentation

### New Documentation

- **[V0.3.0_FEATURES.md](docs/V0.3.0_FEATURES.md)** - Complete feature guide
- **[v0.3.0_features.py](examples/v0.3.0_features.py)** - Comprehensive examples
- **[test_v0_3_0_features.py](tests/test_v0_3_0_features.py)** - Test suite

### Updated Documentation

- **[README.md](README.md)** - Updated with v0.3.0 features
- **[CHANGELOG.md](CHANGELOG.md)** - Detailed changelog
- **[setup.py](setup.py)** - Version bump to 0.3.0

---

## üéØ Real-World Examples

### Example 1: Experimental Physics

```python
from unifyt import UncertainQuantity
import math

# Pendulum experiment
period = UncertainQuantity(2.01, 'second', uncertainty=0.02)
length = UncertainQuantity(1.00, 'meter', uncertainty=0.01)

# Calculate g = 4œÄ¬≤L/T¬≤
g = (4 * math.pi**2 * length) / (period ** 2)
print(f"g = {g}")
print(f"Uncertainty: {g.relative_uncertainty.item():.2%}")
```

### Example 2: Data Analysis

```python
from unifyt import Quantity, BatchConverter

# Multiple sensor readings
readings = [
    Quantity(23.5, 'celsius'),
    Quantity(75.2, 'fahrenheit'),
    Quantity(295, 'kelvin')
]

# Normalize and analyze
converter = BatchConverter()
normalized = converter.normalize_units(readings, 'celsius')
mean_temp = converter.mean_quantities(normalized)
print(f"Mean temperature: {mean_temp}")
```

### Example 3: Performance Optimization

```python
from unifyt import get_profiler, enable_profiling

enable_profiling()
profiler = get_profiler()

# Profile your code
with profiler.profile('data_processing'):
    # Your code here
    pass

# Identify bottlenecks
profiler.print_stats()
```

---

## üß™ Testing

All new features are fully tested:

```bash
# Run all tests
pytest tests/test_v0_3_0_features.py -v

# Run quick test
python test_quick.py
```

---

## üì¶ Installation

```bash
# Install from source
pip install -e .

# Or upgrade existing installation
pip install --upgrade unifyt
```

---

## üéì Learning Resources

1. **Quick Start:** Run `python examples/v0.3.0_features.py`
2. **Feature Guide:** Read `docs/V0.3.0_FEATURES.md`
3. **API Reference:** Check inline documentation
4. **Tests:** Review `tests/test_v0_3_0_features.py`

---

## üîÆ Future Plans (v0.4.0)

- Temperature offset handling (Celsius/Fahrenheit conversions)
- Unit system contexts (SI, Imperial, CGS)
- Symbolic unit algebra
- Integration with pandas DataFrames
- Plotting support with matplotlib
- Database serialization
- REST API for unit conversions

---

## üôè Acknowledgments

Thanks to the scientific Python community and users who requested these features!

---

## üìÑ License

MIT License - See [LICENSE](LICENSE) file for details.

---

## üêõ Bug Reports

Found a bug? Please report it on GitHub Issues.

---

## üí¨ Community

- GitHub: https://github.com/MEERAN2314/unifyt
- Issues: https://github.com/MEERAN2314/unifyt/issues

---

**Unifyt v0.3.0 - Professional Scientific Computing in Python** üöÄ
